<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>ECE297 Storage Server: TreeNode.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<h1>TreeNode.c File Reference</h1>  </div>
</div>
<div class="contents">

<p>In this file we will create the necessary functions to insert, delete, get and set the entries for the tables. Every TableNode has the following: left pointer right pointer struct entry -&gt; has a key and value. place the Node in the BST based on the entry-&gt;key value.  
<a href="#_details">More...</a></p>
<code>#include &lt;stdlib.h&gt;</code><br/>
<code>#include &lt;stdio.h&gt;</code><br/>
<code>#include &lt;stdbool.h&gt;</code><br/>
<code>#include &quot;TreeNode.h&quot;</code><br/>
<code>#include &quot;TreeDB.h&quot;</code><br/>

<p><a href="TreeNode_8c_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a053da5e399c2d8c0174a77e15f0b0fd1"></a><!-- doxytag: member="TreeNode.c::createTreeNode" ref="a053da5e399c2d8c0174a77e15f0b0fd1" args="(struct TreeEntry *entryPtr)" -->
struct <a class="el" href="structTreeNode.html">TreeNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="TreeNode_8c.html#a053da5e399c2d8c0174a77e15f0b0fd1">createTreeNode</a> (struct <a class="el" href="structTreeEntry.html">TreeEntry</a> *entryPtr)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create an entry node for storage in the appropriate table. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a150ed1d227b8b505da6029602390e4fc"></a><!-- doxytag: member="TreeNode.c::deleteTreeNode" ref="a150ed1d227b8b505da6029602390e4fc" args="(struct TreeNode *node)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>deleteTreeNode</b> (struct <a class="el" href="structTreeNode.html">TreeNode</a> *node)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4d3e34665cb3ebf2ccd2b78bccf964ac"></a><!-- doxytag: member="TreeNode.c::setLeft" ref="a4d3e34665cb3ebf2ccd2b78bccf964ac" args="(struct TreeNode *current, struct TreeNode *newLeft)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="TreeNode_8c.html#a4d3e34665cb3ebf2ccd2b78bccf964ac">setLeft</a> (struct <a class="el" href="structTreeNode.html">TreeNode</a> *current, struct <a class="el" href="structTreeNode.html">TreeNode</a> *newLeft)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">sets the left child of the struct <a class="el" href="structTreeNode.html">TreeNode</a>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7ead4f4e8084cf6d0e296614f6a18f1f"></a><!-- doxytag: member="TreeNode.c::setRight" ref="a7ead4f4e8084cf6d0e296614f6a18f1f" args="(struct TreeNode *current, struct TreeNode *newRight)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="TreeNode_8c.html#a7ead4f4e8084cf6d0e296614f6a18f1f">setRight</a> (struct <a class="el" href="structTreeNode.html">TreeNode</a> *current, struct <a class="el" href="structTreeNode.html">TreeNode</a> *newRight)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">sets the right child of the struct <a class="el" href="structTreeNode.html">TreeNode</a> <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad41b406f7ef76564f3ae841ae4348754"></a><!-- doxytag: member="TreeNode.c::getLeft" ref="ad41b406f7ef76564f3ae841ae4348754" args="(struct TreeNode *current)" -->
struct <a class="el" href="structTreeNode.html">TreeNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="TreeNode_8c.html#ad41b406f7ef76564f3ae841ae4348754">getLeft</a> (struct <a class="el" href="structTreeNode.html">TreeNode</a> *current)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">gets the left child of the struct <a class="el" href="structTreeNode.html">TreeNode</a> <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2336affec8e7ca7978f369209ad38c5b"></a><!-- doxytag: member="TreeNode.c::getRight" ref="a2336affec8e7ca7978f369209ad38c5b" args="(struct TreeNode *current)" -->
struct <a class="el" href="structTreeNode.html">TreeNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="TreeNode_8c.html#a2336affec8e7ca7978f369209ad38c5b">getRight</a> (struct <a class="el" href="structTreeNode.html">TreeNode</a> *current)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">gets the right child of the struct <a class="el" href="structTreeNode.html">TreeNode</a> <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3000440864cb6ee05a057ad81880348b"></a><!-- doxytag: member="TreeNode.c::getEntry" ref="a3000440864cb6ee05a057ad81880348b" args="(struct TreeNode *node)" -->
struct <a class="el" href="structTreeEntry.html">TreeEntry</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="TreeNode_8c.html#a3000440864cb6ee05a057ad81880348b">getEntry</a> (struct <a class="el" href="structTreeNode.html">TreeNode</a> *node)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">returns a pointer to the DBentry the struct <a class="el" href="structTreeNode.html">TreeNode</a> contains. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac8c54b48da3d9973f58c1f3b91b75a97"></a><!-- doxytag: member="TreeNode.c::findTable" ref="ac8c54b48da3d9973f58c1f3b91b75a97" args="(struct TreeNode *node, char *name)" -->
struct <a class="el" href="structTreeEntry.html">TreeEntry</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="TreeNode_8c.html#ac8c54b48da3d9973f58c1f3b91b75a97">findTable</a> (struct <a class="el" href="structTreeNode.html">TreeNode</a> *node, char *name)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Search for an entry by comparing a string to the current keys in the BST. If the entry is found, we will return the structure so that the elements can be accessed as necessary. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2664413e6e9c4327500a02967c1a6cf8"></a><!-- doxytag: member="TreeNode.c::insertTable" ref="a2664413e6e9c4327500a02967c1a6cf8" args="(struct TreeNode *node, struct TreeEntry *newEntry)" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="TreeNode_8c.html#a2664413e6e9c4327500a02967c1a6cf8">insertTable</a> (struct <a class="el" href="structTreeNode.html">TreeNode</a> *node, struct <a class="el" href="structTreeEntry.html">TreeEntry</a> *newEntry)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Inserts, if it already exists returns false, otherwise true. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a06e9eeb9e964ef51b3d35b78c48f27e1"></a><!-- doxytag: member="TreeNode.c::removeTable" ref="a06e9eeb9e964ef51b3d35b78c48f27e1" args="(struct TreeNode *node, char *name, struct TreeNode **check)" -->
struct <a class="el" href="structTreeNode.html">TreeNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><b>removeTable</b> (struct <a class="el" href="structTreeNode.html">TreeNode</a> *node, char *name, struct <a class="el" href="structTreeNode.html">TreeNode</a> **check)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structTreeNode.html">TreeNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="TreeNode_8c.html#a1998d28005d1a2c6964a7367931e03de">getLargest</a> (struct <a class="el" href="structTreeNode.html">TreeNode</a> *node)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">In the case where we have to delete an entry that has two entries (to the left, and to the right) We must find the MAX entry from the left subtree and replace it with this.  <a href="#a1998d28005d1a2c6964a7367931e03de"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2b6f3017937b0ddee67367355951b27b"></a><!-- doxytag: member="TreeNode.c::printNodes" ref="a2b6f3017937b0ddee67367355951b27b" args="(struct TreeNode *node)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>printNodes</b> (struct <a class="el" href="structTreeNode.html">TreeNode</a> *node)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>In this file we will create the necessary functions to insert, delete, get and set the entries for the tables. Every TableNode has the following: left pointer right pointer struct entry -&gt; has a key and value. place the Node in the BST based on the entry-&gt;key value. </p>

<p>Definition in file <a class="el" href="TreeNode_8c_source.html">TreeNode.c</a>.</p>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a1998d28005d1a2c6964a7367931e03de"></a><!-- doxytag: member="TreeNode.c::getLargest" ref="a1998d28005d1a2c6964a7367931e03de" args="(struct TreeNode *node)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structTreeNode.html">TreeNode</a>* getLargest </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structTreeNode.html">TreeNode</a> *&nbsp;</td>
          <td class="paramname"> <em>node</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>In the case where we have to delete an entry that has two entries (to the left, and to the right) We must find the MAX entry from the left subtree and replace it with this. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returning the largest element </dd></dl>

<p>Definition at line <a class="el" href="TreeNode_8c_source.html#l00249">249</a> of file <a class="el" href="TreeNode_8c_source.html">TreeNode.c</a>.</p>

</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Tue Mar 26 2013 22:10:56 for ECE297 Storage Server by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
